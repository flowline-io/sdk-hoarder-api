/*
Hoarder API

The API for the Hoarder app

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// BookmarksAPIService BookmarksAPI service
type BookmarksAPIService service

type ApiBookmarksBookmarkIdDeleteRequest struct {
	ctx        context.Context
	ApiService *BookmarksAPIService
	bookmarkId string
}

func (r ApiBookmarksBookmarkIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.BookmarksBookmarkIdDeleteExecute(r)
}

/*
BookmarksBookmarkIdDelete Delete a bookmark

Delete bookmark by its id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bookmarkId
	@return ApiBookmarksBookmarkIdDeleteRequest
*/
func (a *BookmarksAPIService) BookmarksBookmarkIdDelete(ctx context.Context, bookmarkId string) ApiBookmarksBookmarkIdDeleteRequest {
	return ApiBookmarksBookmarkIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		bookmarkId: bookmarkId,
	}
}

// Execute executes the request
func (a *BookmarksAPIService) BookmarksBookmarkIdDeleteExecute(r ApiBookmarksBookmarkIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksBookmarkIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks/{bookmarkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkId"+"}", url.PathEscape(parameterValueToString(r.bookmarkId, "bookmarkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookmarksBookmarkIdGetRequest struct {
	ctx        context.Context
	ApiService *BookmarksAPIService
	bookmarkId string
}

func (r ApiBookmarksBookmarkIdGetRequest) Execute() (*Bookmark, *http.Response, error) {
	return r.ApiService.BookmarksBookmarkIdGetExecute(r)
}

/*
BookmarksBookmarkIdGet Get a single bookmark

Get bookmark by its id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bookmarkId
	@return ApiBookmarksBookmarkIdGetRequest
*/
func (a *BookmarksAPIService) BookmarksBookmarkIdGet(ctx context.Context, bookmarkId string) ApiBookmarksBookmarkIdGetRequest {
	return ApiBookmarksBookmarkIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		bookmarkId: bookmarkId,
	}
}

// Execute executes the request
//
//	@return Bookmark
func (a *BookmarksAPIService) BookmarksBookmarkIdGetExecute(r ApiBookmarksBookmarkIdGetRequest) (*Bookmark, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Bookmark
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksBookmarkIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks/{bookmarkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkId"+"}", url.PathEscape(parameterValueToString(r.bookmarkId, "bookmarkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookmarksBookmarkIdPatchRequest struct {
	ctx                             context.Context
	ApiService                      *BookmarksAPIService
	bookmarkId                      string
	bookmarksBookmarkIdPatchRequest *BookmarksBookmarkIdPatchRequest
}

// The data to update. Only the fields you want to update need to be provided.
func (r ApiBookmarksBookmarkIdPatchRequest) BookmarksBookmarkIdPatchRequest(bookmarksBookmarkIdPatchRequest BookmarksBookmarkIdPatchRequest) ApiBookmarksBookmarkIdPatchRequest {
	r.bookmarksBookmarkIdPatchRequest = &bookmarksBookmarkIdPatchRequest
	return r
}

func (r ApiBookmarksBookmarkIdPatchRequest) Execute() (*BookmarksBookmarkIdPatch200Response, *http.Response, error) {
	return r.ApiService.BookmarksBookmarkIdPatchExecute(r)
}

/*
BookmarksBookmarkIdPatch Update a bookmark

Update bookmark by its id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bookmarkId
	@return ApiBookmarksBookmarkIdPatchRequest
*/
func (a *BookmarksAPIService) BookmarksBookmarkIdPatch(ctx context.Context, bookmarkId string) ApiBookmarksBookmarkIdPatchRequest {
	return ApiBookmarksBookmarkIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		bookmarkId: bookmarkId,
	}
}

// Execute executes the request
//
//	@return BookmarksBookmarkIdPatch200Response
func (a *BookmarksAPIService) BookmarksBookmarkIdPatchExecute(r ApiBookmarksBookmarkIdPatchRequest) (*BookmarksBookmarkIdPatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BookmarksBookmarkIdPatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksBookmarkIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks/{bookmarkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkId"+"}", url.PathEscape(parameterValueToString(r.bookmarkId, "bookmarkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bookmarksBookmarkIdPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookmarksBookmarkIdTagsDeleteRequest struct {
	ctx                                context.Context
	ApiService                         *BookmarksAPIService
	bookmarkId                         string
	bookmarksBookmarkIdTagsPostRequest *BookmarksBookmarkIdTagsPostRequest
}

// The tags to detach.
func (r ApiBookmarksBookmarkIdTagsDeleteRequest) BookmarksBookmarkIdTagsPostRequest(bookmarksBookmarkIdTagsPostRequest BookmarksBookmarkIdTagsPostRequest) ApiBookmarksBookmarkIdTagsDeleteRequest {
	r.bookmarksBookmarkIdTagsPostRequest = &bookmarksBookmarkIdTagsPostRequest
	return r
}

func (r ApiBookmarksBookmarkIdTagsDeleteRequest) Execute() (*BookmarksBookmarkIdTagsDelete200Response, *http.Response, error) {
	return r.ApiService.BookmarksBookmarkIdTagsDeleteExecute(r)
}

/*
BookmarksBookmarkIdTagsDelete Detach tags from a bookmark

Detach tags from a bookmark

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bookmarkId
	@return ApiBookmarksBookmarkIdTagsDeleteRequest
*/
func (a *BookmarksAPIService) BookmarksBookmarkIdTagsDelete(ctx context.Context, bookmarkId string) ApiBookmarksBookmarkIdTagsDeleteRequest {
	return ApiBookmarksBookmarkIdTagsDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		bookmarkId: bookmarkId,
	}
}

// Execute executes the request
//
//	@return BookmarksBookmarkIdTagsDelete200Response
func (a *BookmarksAPIService) BookmarksBookmarkIdTagsDeleteExecute(r ApiBookmarksBookmarkIdTagsDeleteRequest) (*BookmarksBookmarkIdTagsDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BookmarksBookmarkIdTagsDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksBookmarkIdTagsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks/{bookmarkId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkId"+"}", url.PathEscape(parameterValueToString(r.bookmarkId, "bookmarkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bookmarksBookmarkIdTagsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookmarksBookmarkIdTagsPostRequest struct {
	ctx                                context.Context
	ApiService                         *BookmarksAPIService
	bookmarkId                         string
	bookmarksBookmarkIdTagsPostRequest *BookmarksBookmarkIdTagsPostRequest
}

// The tags to attach.
func (r ApiBookmarksBookmarkIdTagsPostRequest) BookmarksBookmarkIdTagsPostRequest(bookmarksBookmarkIdTagsPostRequest BookmarksBookmarkIdTagsPostRequest) ApiBookmarksBookmarkIdTagsPostRequest {
	r.bookmarksBookmarkIdTagsPostRequest = &bookmarksBookmarkIdTagsPostRequest
	return r
}

func (r ApiBookmarksBookmarkIdTagsPostRequest) Execute() (*BookmarksBookmarkIdTagsPost200Response, *http.Response, error) {
	return r.ApiService.BookmarksBookmarkIdTagsPostExecute(r)
}

/*
BookmarksBookmarkIdTagsPost Attach tags to a bookmark

Attach tags to a bookmark

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bookmarkId
	@return ApiBookmarksBookmarkIdTagsPostRequest
*/
func (a *BookmarksAPIService) BookmarksBookmarkIdTagsPost(ctx context.Context, bookmarkId string) ApiBookmarksBookmarkIdTagsPostRequest {
	return ApiBookmarksBookmarkIdTagsPostRequest{
		ApiService: a,
		ctx:        ctx,
		bookmarkId: bookmarkId,
	}
}

// Execute executes the request
//
//	@return BookmarksBookmarkIdTagsPost200Response
func (a *BookmarksAPIService) BookmarksBookmarkIdTagsPostExecute(r ApiBookmarksBookmarkIdTagsPostRequest) (*BookmarksBookmarkIdTagsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BookmarksBookmarkIdTagsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksBookmarkIdTagsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks/{bookmarkId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkId"+"}", url.PathEscape(parameterValueToString(r.bookmarkId, "bookmarkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bookmarksBookmarkIdTagsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookmarksGetRequest struct {
	ctx        context.Context
	ApiService *BookmarksAPIService
	archived   *bool
	favourited *bool
	limit      *float32
	cursor     *string
}

func (r ApiBookmarksGetRequest) Archived(archived bool) ApiBookmarksGetRequest {
	r.archived = &archived
	return r
}

func (r ApiBookmarksGetRequest) Favourited(favourited bool) ApiBookmarksGetRequest {
	r.favourited = &favourited
	return r
}

func (r ApiBookmarksGetRequest) Limit(limit float32) ApiBookmarksGetRequest {
	r.limit = &limit
	return r
}

func (r ApiBookmarksGetRequest) Cursor(cursor string) ApiBookmarksGetRequest {
	r.cursor = &cursor
	return r
}

func (r ApiBookmarksGetRequest) Execute() (*PaginatedBookmarks, *http.Response, error) {
	return r.ApiService.BookmarksGetExecute(r)
}

/*
BookmarksGet Get all bookmarks

Get all bookmarks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBookmarksGetRequest
*/
func (a *BookmarksAPIService) BookmarksGet(ctx context.Context) ApiBookmarksGetRequest {
	return ApiBookmarksGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedBookmarks
func (a *BookmarksAPIService) BookmarksGetExecute(r ApiBookmarksGetRequest) (*PaginatedBookmarks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedBookmarks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.favourited != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "favourited", r.favourited, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookmarksPostRequest struct {
	ctx                  context.Context
	ApiService           *BookmarksAPIService
	bookmarksPostRequest *BookmarksPostRequest
}

// The bookmark to create
func (r ApiBookmarksPostRequest) BookmarksPostRequest(bookmarksPostRequest BookmarksPostRequest) ApiBookmarksPostRequest {
	r.bookmarksPostRequest = &bookmarksPostRequest
	return r
}

func (r ApiBookmarksPostRequest) Execute() (*Bookmark, *http.Response, error) {
	return r.ApiService.BookmarksPostExecute(r)
}

/*
BookmarksPost Create a new bookmark

Create a new bookmark

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBookmarksPostRequest
*/
func (a *BookmarksAPIService) BookmarksPost(ctx context.Context) ApiBookmarksPostRequest {
	return ApiBookmarksPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Bookmark
func (a *BookmarksAPIService) BookmarksPostExecute(r ApiBookmarksPostRequest) (*Bookmark, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Bookmark
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BookmarksAPIService.BookmarksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bookmarks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bookmarksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
